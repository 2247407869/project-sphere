<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Project Sphere | Dialogue</title>
    <!-- å¼ºåˆ¶ç¦ç”¨ç¼“å­˜ -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Outfit:wght@300;600&display=swap"
        rel="stylesheet">
    <style>
        /* VERSION WATERMARK */
        #version-tag {
            position: fixed;
            top: 0;
            right: 0;
            background: #ff4444;
            color: white;
            padding: 5px 10px;
            z-index: 9999;
            font-weight: bold;
            font-size: 12px;
            pointer-events: none;
        }

        :root {
            --bg-color: #0d0d12;
            --card-bg: rgba(255, 255, 255, 0.03);
            --accent-color: #6366f1;
            --user-msg-bg: #6366f1;
            --ai-msg-bg: rgba(255, 255, 255, 0.08);
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            height: 100%;
            height: -webkit-fill-available;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            padding: 0.6rem;
            background: rgba(13, 13, 18, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--glass-border);
            text-align: center;
            z-index: 10;
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            background: linear-gradient(135deg, #fff 0%, var(--accent-color) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Chat Area */
        /* Memory Bar */
        #memory-bar {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--glass-border);
            padding: 0.7rem 1.2rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            z-index: 5;
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 0.5rem;
            max-height: 48px;
            /* é»˜è®¤ç´§å‡‘é«˜åº¦ */
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            cursor: pointer;
        }

        #memory-bar.expanded {
            max-height: 48vh;
            background: rgba(13, 13, 18, 0.98);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            overscroll-behavior: contain;
        }

        #memory-content {
            flex: 1;
            line-height: 1.5;
            word-break: break-word;
            opacity: 0.8;
        }

        #memory-bar.expanded #memory-content {
            opacity: 1;
        }

        .vault-btn {
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            cursor: pointer;
            white-space: nowrap;
        }

        /* äº‹å®çœ‹æ¿ä¸å¾…åŠçœ‹æ¿æ¨¡æ€æ¡† */
        #fact-vault,
        #todo-vault {
            display: none;
            position: fixed;
            top: 10%;
            left: 5%;
            width: 90%;
            height: 80%;
            background: rgba(13, 13, 18, 0.98);
            backdrop-filter: blur(25px);
            z-index: 2000;
            border-radius: 24px;
            border: 1px solid var(--glass-border);
            padding: 1.5rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            overscroll-behavior: contain;
            color: var(--text-primary);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
        }

        .todo-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.03);
            margin-bottom: 0.8rem;
            padding: 1rem;
            border-radius: 16px;
            transition: opacity 0.3s;
        }

        .todo-item.completed {
            opacity: 0.5;
        }

        .todo-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .todo-text {
            flex: 1;
            font-size: 0.95rem;
        }

        .fact-item {
            background: rgba(255, 255, 255, 0.03);
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 16px;
            border-left: 3px solid var(--accent-color);
        }

        .fact-time {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 0.3rem;
        }

        .fact-summary {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--accent-color);
        }

        .fact-origin {
            font-size: 0.85rem;
            opacity: 0.8;
            line-height: 1.4;
        }

        #chat-container {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .message {
            max-width: 85%;
            padding: 1rem 1.2rem;
            border-radius: 20px;
            font-size: 0.95rem;
            line-height: 1.5;
            position: relative;
            /* animation: slideIn 0.3s ease-out; ä¸´æ—¶ç¦ç”¨ä»¥ä¼˜åŒ–ç§»åŠ¨ç«¯æ»‘åŠ¨ */
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-message {
            align-self: flex-end;
            background: var(--user-msg-bg);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .ai-message {
            align-self: flex-start;
            background: var(--ai-msg-bg);
            border: 1px solid var(--glass-border);
            border-bottom-left-radius: 4px;
        }

        .ai-message::before {
            content: 'Sphere';
            position: absolute;
            top: -1.2rem;
            left: 0.2rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Message Delete Button */
        .message-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            max-width: 90%;
        }

        .message-wrapper.user-wrapper {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-wrapper.ai-wrapper {
            align-self: flex-start;
        }

        .delete-btn {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #ef4444;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 0.7rem;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.2s;
            flex-shrink: 0;
            margin-top: 0.5rem;
        }

        .message-wrapper:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn:hover {
            background: rgba(239, 68, 68, 0.4);
        }

        /* Input Area */
        .input-area {
            padding: 1.2rem;
            background: rgba(13, 13, 18, 0.9);
            border-top: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .input-row {
            display: flex;
            gap: 0.8rem;
        }

        textarea {
            flex: 1;
            height: 50px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 0.8rem 1.2rem;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 1rem;
            resize: none;
            outline: none;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            border-color: var(--accent-color);
        }

        .btn-circle {
            width: 50px;
            height: 50px;
            background: var(--accent-color);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .action-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .capture-btn {
            background: transparent;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            padding: 0.4rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
        }

        /* Loading */
        .typing {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: 0.5rem;
            display: none;
        }

        /* Scrollbar */
        #chat-container::-webkit-scrollbar {
            width: 4px;
        }

        #chat-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* Session Management Buttons */
        .session-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .session-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .session-btn:hover {
            background: rgba(99, 102, 241, 0.3);
            color: white;
            border-color: var(--accent-color);
        }

        .session-btn.danger:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: #ef4444;
        }

        /* Summary Edit Modal */
        #summary-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        #summary-modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-color);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 1.5rem;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }

        #summary-textarea {
            width: 100%;
            height: 200px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            outline: none;
        }

        #summary-textarea:focus {
            border-color: var(--accent-color);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.8rem;
            margin-top: 1rem;
        }

        .modal-btn {
            padding: 0.6rem 1.2rem;
            border-radius: 12px;
            font-size: 0.85rem;
            cursor: pointer;
            border: none;
        }

        .modal-btn.primary {
            background: var(--accent-color);
            color: white;
        }

        .modal-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
    </style>
</head>

<body>
    <div id="version-tag">V2.5 - ROOT FIX</div>
    <header>
        <h1>Project Sphere</h1>
    </header>

    <div id="memory-bar" onclick="toggleMemoryBar(event)">
        <span><strong>Context:</strong> <span id="memory-content">æ­£åœ¨å”¤é†’è®°å¿†...</span></span>
        <div class="session-actions" onclick="event.stopPropagation()">
            <button class="session-btn" onclick="openSummaryEditor()">ğŸ“ ç¼–è¾‘</button>
            <button class="session-btn danger" onclick="clearSession()">ğŸ—‘ï¸ æ¸…ç©º</button>
        </div>
    </div>

    <!-- Summary Edit Modal -->
    <div id="summary-modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">ç¼–è¾‘åŠ¨æ€æ‘˜è¦</span>
                <button class="modal-close" onclick="closeSummaryEditor()">&times;</button>
            </div>
            <textarea id="summary-textarea" placeholder="è¾“å…¥åŠ¨æ€æ‘˜è¦..."></textarea>
            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="closeSummaryEditor()">å–æ¶ˆ</button>
                <button class="modal-btn primary" onclick="saveSummary()">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <div id="chat-container">
        <div class="message ai-message">
            æ¬¢è¿æ¥åˆ° Sphereã€‚æˆ‘æ˜¯ä½ çš„ç¬¬äºŒå¤§è„‘ï¼Œå¯ä»¥éšæ—¶æŸ¥é˜…ä½ çš„é•¿æœŸè®°å¿†ã€‚
        </div>
    </div>

    <div class="input-area">
        <div class="action-row">
            <span id="typing-indicator" class="typing">Sphere æ­£åœ¨æ€è€ƒ...</span>
        </div>
        <div class="input-row">
            <textarea id="msg-input" placeholder="è¾“å…¥çµæ„Ÿæˆ–é—®é¢˜..."></textarea>
            <button class="btn-circle" onclick="sendMessage()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round" style="color: white;">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
            </button>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const msgInput = document.getElementById('msg-input');
        const typingIndicator = document.getElementById('typing-indicator');
        const memoryContent = document.getElementById('memory-content');
        let history = [];
        let lastSentContent = ''; // ç¼“å­˜æœ€åä¸€æ¬¡å‘é€çš„å†…å®¹
        let currentSummary = '';  // å­˜å‚¨ L2 åŠ¨æ€æ‘˜è¦

        // --- é‰´æƒå·²ç§»é™¤ ---

        // --- åˆå§‹åŒ–ï¼šä»åç«¯åŠ è½½ä¼šè¯ï¼ˆåç«¯ä¸ºå”¯ä¸€çœŸå®æ¥æºï¼‰---
        window.onload = async () => {
            console.log("[Frontend] Version 2.2 - Stream Fix Loaded");
            try {
                const response = await fetch('/session/load');
                const data = await response.json();

                history = data.history || [];
                currentSummary = data.summary || '';

                await renderHistory();
                console.log("[Init] Loaded session from backend, history length:", history.length);
            } catch (e) {
                console.error("Failed to load session from backend:", e);
                history = [];
                currentSummary = '';
            }
        };

        async function renderHistory() {
            chatContainer.innerHTML = '';
            let displayIndex = 0;
            history.forEach((item, realIndex) => {
                // è·³è¿‡ system æ¶ˆæ¯ï¼ˆæ³¨å…¥çš„è®°å¿†å†…å®¹ï¼Œä¸éœ€è¦æ˜¾ç¤ºç»™ç”¨æˆ·ï¼‰
                if (item.role === 'system') return;
                // åªæœ‰ç”¨æˆ·æ¶ˆæ¯æ‰ä¼ é€’ç´¢å¼•ï¼ˆç”¨äºåˆ é™¤ï¼‰
                const msgIndex = item.role === 'user' ? realIndex : null;
                addMessage(item.content, item.role === 'user' ? 'user' : 'ai', false, msgIndex);
                displayIndex++;
            });

            // æ˜¾ç¤ºå½“å‰æ‘˜è¦
            let displayContent = "ğŸ“ [åŠ¨æ€æ‘˜è¦]:\n" + (currentSummary || "å°šæ— åŠ¨æ€æ‘˜è¦");
            memoryContent.innerText = displayContent;
        }

        async function sendMessage() {
            const text = msgInput.value.trim();
            if (!text) return;

            lastSentContent = text; // æ›´æ–°ç¼“å­˜
            const userMsgIndex = history.length; // è®°å½•å½“å‰ç´¢å¼•ï¼Œç”¨äºåˆ é™¤æŒ‰é’®
            addMessage(text, 'user', true, userMsgIndex);
            msgInput.value = '';

            // ç«‹å³å°†ç”¨æˆ·æ¶ˆæ¯åŠ å…¥ history
            history.push({ role: 'user', content: text });
            localStorage.setItem('sphere_history', JSON.stringify(history));

            // åˆ›å»ºä¸€ä¸ªå ä½çš„ AI æ¶ˆæ¯å®¹å™¨
            const aiMsgDiv = addMessage('', 'ai');
            typingIndicator.style.display = 'block';

            const payload = {
                message: text,
                history: history.slice(0, -1), // å‘é€æ—¶ä¸å«åˆšåŠ çš„è¿™æ¡
                summary: currentSummary
            };
            console.info("ğŸ“¤ [API Request Payload]:", payload);

            try {
                const response = await fetch(`/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullContent = "";
                let statusLog = "";
                let actualContent = "";
                let lastChunkTime = Date.now();
                let streamTimeout = null;

                // è¶…æ—¶è‡ªæ„ˆæœºåˆ¶ï¼šé˜²æ­¢æ— é™ç­‰å¾…ï¼ˆå¢åŠ åˆ°30ç§’ï¼Œæ”¯æŒå¤æ‚æŸ¥è¯¢ï¼‰
                const checkTimeout = () => {
                    const now = Date.now();
                    if (now - lastChunkTime > 30000 && actualContent.trim().length > 0) {
                        console.warn("[Stream] Timeout detected (30s). Forcing completion.");
                        typingIndicator.style.display = 'none';
                        reader.cancel().catch(e => console.log("Reader cancel:", e));
                    } else {
                        streamTimeout = requestAnimationFrame(checkTimeout);
                    }
                };
                streamTimeout = requestAnimationFrame(checkTimeout);

                let streamCompleted = false;
                
                while (true) {
                    const { done, value } = await reader.read();
                    lastChunkTime = Date.now();

                    if (done) {
                        console.log("[Stream] Reader done, breaking loop.");
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });
                    fullContent += chunk;

                    // è§£æ SSE æ ¼å¼ï¼ševent: xxx\ndata: xxx\n\n
                    const events = fullContent.split('\n\n');
                    for (let i = 0; i < events.length - 1; i++) {
                        const eventBlock = events[i];
                        let eventType = 'content';
                        let eventData = '';

                        for (const line of eventBlock.split('\n')) {
                            if (line.startsWith('event: ')) {
                                eventType = line.substring(7);
                            } else if (line.startsWith('data: ')) {
                                eventData = line.substring(6);
                            }
                        }

                        if (eventType === 'status') {
                            statusLog = eventData;
                            // åªæœ‰åœ¨æµæœªå®Œæˆæ—¶æ‰æ˜¾ç¤ºçŠ¶æ€
                            if (!streamCompleted && typingIndicator.style.display !== 'none') {
                                typingIndicator.style.display = 'block';
                                // ç‰¹æ®Šå¤„ç†å·¥å…·è°ƒç”¨çŠ¶æ€
                                if (eventData.includes('æ­£åœ¨æŸ¥é˜…è®°å¿†') || eventData.includes('fetch_memory')) {
                                    typingIndicator.innerText = 'ğŸ§  ' + eventData;
                                } else {
                                    typingIndicator.innerText = eventData;
                                }
                            }
                        } else if (eventType === 'content') {
                            actualContent += eventData;
                            aiMsgDiv.innerText = actualContent;
                        } else if (eventType === 'metadata') {
                            try {
                                const metadata = JSON.parse(eventData);
                                currentSummary = metadata.summary || currentSummary;
                                memoryContent.innerText = "ğŸ“ [åŠ¨æ€æ‘˜è¦]:\n" + (currentSummary || "å°šæ— åŠ¨æ€æ‘˜è¦");
                                console.log("[Metadata] Summary updated:", currentSummary.substring(0, 50) + "...");

                                if (metadata.history && metadata.history.length > 0) {
                                    history = metadata.history;
                                    console.log("[Metadata] Using backend history, length:", history.length);
                                }
                            } catch (e) {
                                console.warn("Metadata parse failed:", e);
                            }
                            // ä¸è¦åœ¨è¿™é‡Œéšè—indicatorï¼Œç­‰doneäº‹ä»¶
                        } else if (eventType === 'done') {
                            console.log("[Stream] Received done event. Marking as completed.");
                            streamCompleted = true;
                            // ç«‹å³å¼ºåˆ¶æ¸…ç†çŠ¶æ€
                            typingIndicator.style.setProperty('display', 'none', 'important');
                            typingIndicator.innerText = 'Sphere æ­£åœ¨æ€è€ƒ...';
                            console.log("[Stream] Done event - forced hide typing indicator");
                            break;
                        } else if (eventType === 'error') {
                            console.error("[Stream] Error:", eventData);
                        }
                    }
                    // ä¿ç•™æœªå®Œæˆçš„æœ€åä¸€ä¸ªäº‹ä»¶å—
                    fullContent = events[events.length - 1];

                    const isAtBottom = chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight < 100;
                    if (isAtBottom) {
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }

                    // å¦‚æœæ”¶åˆ°doneäº‹ä»¶ï¼Œé€€å‡ºå¾ªç¯
                    if (streamCompleted) break;
                } // while end

                // æ¸…é™¤è¶…æ—¶æ£€æµ‹
                if (streamTimeout) cancelAnimationFrame(streamTimeout);

                // ç¡®ä¿çŠ¶æ€æ¸…ç†
                console.log("[Stream] Cleaning up state. Stream completed:", streamCompleted);
                console.log("[Stream] Final content length:", actualContent.length);
                console.log("[Stream] Typing indicator display:", typingIndicator.style.display);
                
                // å¼ºåˆ¶æ¸…ç†çŠ¶æ€
                typingIndicator.style.setProperty('display', 'none', 'important');
                typingIndicator.innerText = 'Sphere æ­£åœ¨æ€è€ƒ...';
                
                console.log("[Stream] After cleanup - Typing indicator display:", typingIndicator.style.display);

                let finalContent = actualContent.trim();

                if (finalContent) {
                    aiMsgDiv.innerText = finalContent;

                    // æ£€æŸ¥åç«¯è¿”å›çš„ history æ˜¯å¦å·²ç»åŒ…å«è¿™æ¡å›å¤
                    const lastHistoryItem = history[history.length - 1];
                    const alreadyHasReply = lastHistoryItem &&
                        (lastHistoryItem.role === 'assistant' || lastHistoryItem.role === 'ai') &&
                        lastHistoryItem.content === finalContent;

                    // å¦‚æœåç«¯ history æ²¡æœ‰åŒ…å«è¿™æ¡å›å¤ï¼Œæ‰‹åŠ¨æ·»åŠ ï¼ˆfallback æœºåˆ¶ï¼‰
                    if (!alreadyHasReply) {
                        history.push({ role: 'assistant', content: finalContent });
                        console.log("[Fallback] Manually pushed AI reply to history");
                    }
                } else {
                    console.warn("[Stream] No content received, this might indicate an issue");
                }
            } catch (err) {
                console.error("Chat Error Caught:", err);
                aiMsgDiv.innerText = 'è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æœåŠ¡ã€‚';
                // ç¡®ä¿æ¸…ç†çŠ¶æ€
                if (streamTimeout) cancelAnimationFrame(streamTimeout);
                typingIndicator.style.setProperty('display', 'none', 'important');
                typingIndicator.innerText = 'Sphere æ­£åœ¨æ€è€ƒ...';
            } finally {
                console.log("[Stream] Finally block executed. Ensuring complete cleanup.");
                // ç¡®ä¿æ— è®ºå¦‚ä½•æœ€åéƒ½éšè—å¹¶é‡ç½®çŠ¶æ€
                if (typingIndicator) {
                    typingIndicator.style.setProperty('display', 'none', 'important');
                    typingIndicator.innerText = 'Sphere æ­£åœ¨æ€è€ƒ...';
                }
                // æ¸…ç†å¯èƒ½æ®‹ç•™çš„è¶…æ—¶æ£€æµ‹
                if (streamTimeout) {
                    cancelAnimationFrame(streamTimeout);
                    streamTimeout = null;
                }
                
                // æ·»åŠ ä¸€ä¸ªå»¶è¿Ÿç¡®ä¿çŠ¶æ€æ¸…ç†
                setTimeout(() => {
                    if (typingIndicator && typingIndicator.style.display !== 'none') {
                        console.warn("[Stream] Force hiding typing indicator after delay");
                        typingIndicator.style.setProperty('display', 'none', 'important');
                        typingIndicator.innerText = 'Sphere æ­£åœ¨æ€è€ƒ...';
                        
                        // æœ€åæ‰‹æ®µï¼šç›´æ¥ç§»é™¤å¹¶é‡æ–°åˆ›å»ºå…ƒç´ 
                        const parent = typingIndicator.parentNode;
                        const newIndicator = document.createElement('span');
                        newIndicator.id = 'typing-indicator';
                        newIndicator.className = 'typing';
                        newIndicator.innerText = 'Sphere æ­£åœ¨æ€è€ƒ...';
                        newIndicator.style.display = 'none';
                        parent.replaceChild(newIndicator, typingIndicator);
                        console.log("[Stream] Replaced typing indicator element");
                    }
                }, 1000);
            }
        }

        async function syncToCloud() {
            try {
                await fetch('/session/sync', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ history, summary: currentSummary })
                });
            } catch (e) {
                console.warn("Cloud sync failed:", e);
            }
        }

        async function triggerCapture() {
            // ä¼˜å…ˆæ•è·è¾“å…¥æ¡†å†…å®¹ï¼Œè‹¥ä¸ºç©ºåˆ™å°è¯•æ•è·æœ€åä¸€æ¡å‘é€çš„æ¶ˆæ¯
            let text = msgInput.value.trim();
            if (!text) {
                text = lastSentContent;
            }

            if (!text) {
                alert('è¯·å…ˆè¾“å…¥éœ€è¦æ•è·çš„å†…å®¹ï¼Œæˆ–å‘é€ä¸€æ¡æ¶ˆæ¯ã€‚');
                return;
            }

            typingIndicator.innerText = 'æ­£åœ¨ç‰©ç†åŒæ­¥...';
            typingIndicator.style.display = 'block';

            try {
                const response = await fetch(`/collect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: text, source: 'mobile_chat' })
                });
                const data = await response.json();
                addMessage(`âœ… çµæ„Ÿå·²åŒæ­¥è‡³äº‘ç«¯äº‹å®äº‘ (L3)\næ‘˜è¦ï¼š${data.summary}`, 'ai');
                if (msgInput.value.trim() === text) {
                    msgInput.value = '';
                }
            } catch (err) {
                alert('æ•è·å¤±è´¥');
            } finally {
                typingIndicator.style.display = 'none';
                typingIndicator.innerText = 'Sphere æ­£åœ¨æ€è€ƒ...';
            }
        }

        function addMessage(text, role, smooth = true, historyIndex = null) {
            // ä½¿ç”¨ wrapper åŒ…è£¹æ¶ˆæ¯å’Œåˆ é™¤æŒ‰é’®
            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${role}-wrapper`;

            const div = document.createElement('div');
            div.className = `message ${role}-message`;
            div.innerText = text;
            if (!smooth) div.style.animation = 'none';

            wrapper.appendChild(div);

            // åªæœ‰ç”¨æˆ·æ¶ˆæ¯æ‰æ˜¾ç¤ºåˆ é™¤æŒ‰é’®
            if (role === 'user' && historyIndex !== null) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = 'âœ•';
                deleteBtn.title = 'åˆ é™¤è¿™è½®å¯¹è¯';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteMessage(historyIndex);
                };
                wrapper.appendChild(deleteBtn);
            }

            chatContainer.appendChild(wrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            return div;
        }

        async function deleteMessage(index) {
            if (!confirm('ç¡®å®šåˆ é™¤è¿™è½®å¯¹è¯å—ï¼Ÿ')) return;

            try {
                const response = await fetch(`/session/message/${index}`, {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.status === 'deleted') {
                    history = data.history;
                    await renderHistory();
                    console.log(`[Session] Deleted ${data.count} messages`);
                } else {
                    alert('åˆ é™¤å¤±è´¥ï¼š' + (data.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (e) {
                console.error('Delete message failed:', e);
                alert('åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }

        async function toggleVault() {
            const vault = document.getElementById('fact-vault');
            if (vault.style.display === 'block') {
                vault.style.display = 'none';
                return;
            }

            vault.style.display = 'block';
            const list = document.getElementById('vault-list');
            list.innerHTML = 'æ­£åœ¨è¯»å–äº‹å®äº‘...';

            try {
                console.log("Fetching facts from /facts ...");
                const response = await fetch('/facts');
                console.log("Facts Response Status:", response.status);
                const facts = await response.json();
                console.log("Facts Data:", facts);

                if (facts.length === 0) {
                    list.innerHTML = '<div style="text-align:center; margin-top:50px; opacity:0.5;">å®åº“å°šç©ºï¼Œå®Œæˆ Capture ä»¥å½’æ¡£äº‹å®ã€‚</div>';
                    return;
                }

                list.innerHTML = facts.reverse().map(f => {
                    const contentStr = f.content || '';
                    const displayOrigin = contentStr ? `"${contentStr.substring(0, 100)}${contentStr.length > 100 ? '...' : ''}"` : '<em>(è‡ªåŠ¨æ²‰æ·€äº‹å®)</em>';
                    return `
                        <div class="fact-item">
                            <div class="fact-time">${new Date(f.timestamp).toLocaleString()}</div>
                            <div class="fact-summary">${f.summary || 'æ— æ‘˜è¦'}</div>
                            <div class="fact-origin">${displayOrigin}</div>
                        </div>
                    `;
                }).join('');
            } catch (e) {
                list.innerHTML = 'è¯»å–å¤±è´¥ï¼š' + e.message;
            }
        }

        let todos = [];

        async function toggleTodoVault() {
            const vault = document.getElementById('todo-vault');
            if (vault.style.display === 'block') {
                vault.style.display = 'none';
                return;
            }
            vault.style.display = 'block';
            await loadTodos();
        }

        async function loadTodos() {
            try {
                console.log("Fetching todos from /todos ...");
                const response = await fetch('/todos');
                console.log("Todos Response Status:", response.status);
                todos = await response.json();
                console.log("Todos Data:", todos);
                renderTodos();
            } catch (e) {
                document.getElementById('todo-list').innerText = 'ä»»åŠ¡åŠ è½½å¤±è´¥';
            }
        }

        function renderTodos() {
            const list = document.getElementById('todo-list');
            if (!todos || todos.length === 0) {
                list.innerHTML = '<div style="text-align:center; margin-top:50px; opacity:0.5;">æš‚æ— å¾…åŠäº‹é¡¹ã€‚</div>';
                return;
            }
            list.innerHTML = todos.map(t => {
                const taskText = t.task || (typeof t === 'string' ? t : 'æœªçŸ¥ä»»åŠ¡');
                return `
                    <div class="todo-item ${t.completed ? 'completed' : ''}">
                        <input type="checkbox" ${t.completed ? 'checked' : ''} onchange="toggleTodoStatus('${t.id || 'temp'}')">
                        <span class="todo-text">${taskText}</span>
                    </div>
                `;
            }).join('');
        }

        async function toggleTodoStatus(id) {
            const todo = todos.find(t => t.id === id);
            if (todo) {
                todo.completed = !todo.completed;
                renderTodos();
                // åŒæ­¥è‡³æœåŠ¡å™¨
                try {
                    await fetch('/todos/sync', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(todos)
                    });
                } catch (e) {
                    console.error("Todo Sync Failed", e);
                }
            }
        }

        function toggleMemoryBar(e) {
            // é˜²æ­¢ç‚¹å‡»æŒ‰é’®è§¦å‘æŠ˜å 
            if (e.target.closest('.vault-btn')) return;
            const bar = document.getElementById('memory-bar');
            bar.classList.toggle('expanded');
        }

        // ===== Session Management Functions =====
        function openSummaryEditor() {
            const modal = document.getElementById('summary-modal');
            const textarea = document.getElementById('summary-textarea');
            textarea.value = currentSummary;
            modal.classList.add('active');
        }

        function closeSummaryEditor() {
            document.getElementById('summary-modal').classList.remove('active');
        }

        async function saveSummary() {
            const textarea = document.getElementById('summary-textarea');
            const newSummary = textarea.value.trim();

            try {
                const response = await fetch('/session/summary', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ summary: newSummary })
                });
                const data = await response.json();

                if (data.status === 'updated') {
                    currentSummary = newSummary;
                    memoryContent.innerText = "ğŸ“ [åŠ¨æ€æ‘˜è¦]:\n" + (currentSummary || "å°šæ— åŠ¨æ€æ‘˜è¦");
                    closeSummaryEditor();
                    console.log('[Session] Summary saved successfully');
                } else {
                    alert('ä¿å­˜å¤±è´¥ï¼š' + (data.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (e) {
                console.error('Save summary failed:', e);
                alert('ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }

        async function clearSession() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å¯¹è¯è®°å½•å’Œæ‘˜è¦å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                return;
            }

            try {
                const response = await fetch('/session/clear', {
                    method: 'DELETE'
                });
                const data = await response.json();

                if (data.status === 'cleared') {
                    history = [];
                    currentSummary = '';
                    chatContainer.innerHTML = '<div class="message ai-message">å¯¹è¯å·²æ¸…ç©ºã€‚æˆ‘æ˜¯ä½ çš„ç¬¬äºŒå¤§è„‘ï¼Œéšæ—¶å¯ä»¥å¼€å§‹æ–°çš„å¯¹è¯ã€‚</div>';
                    memoryContent.innerText = "ğŸ“ [åŠ¨æ€æ‘˜è¦]:\nå°šæ— åŠ¨æ€æ‘˜è¦";
                    console.log('[Session] Cleared all history');
                } else {
                    alert('æ¸…ç©ºå¤±è´¥ï¼š' + (data.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (e) {
                console.error('Clear session failed:', e);
                alert('æ¸…ç©ºå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }

        msgInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    </script>
</body>

</html>